# Java Variables
---
## What is a variable ?
- It is a container which holds a value
- How to declare ?
```Datatype Variable_Name = value;```
Eg : int         i        =  1;
    boolean    bool       = True ;
---
- Java is **Static typed language** i.e. we mandatorily have do define the datatype of a variable.
- Java is a **Strongly Typed Language** i.e there is a restriction on whatvalue can be assigned to a variable.

---
## Types of variables
![alt text](image.png)

---

## Java Primitive Data Types
| Type     | Size (bits) | Range                                                                 | Default Value |
|----------|------------|------------------------------------------------------------------------|--------------|
| byte     | 8          | -128 to 127                                                            | 0            |
| short    | 16         | -32,768 to 32,767                                                      | 0            |
| int      | 32         | -2^31 to 2^31 - 1  (-2,147,483,648 to 2,147,483,647)                | 0            |
| long     | 64         | -2^63 to 2^63 - 1                                                      | 0L           |
| float    | 32         | Â±1.4E-45 to Â±3.4028235E38                                             | 0.0f         |
| double   | 64         | Â±4.9E-324 to Â±1.7976931348623157E308                                  | 0.0d         |
| char     | 16         | 0 to 65,535 (Unicode characters)                                      | '\u0000'     |
| boolean  | JVM dependent (typically 1 bit internally) | true / false                          | false        |

### Important Points
- Default values apply only to instance variables, not local variables.
- `char` stores Unicode characters (0 to 65535).
- `boolean` size is not precisely defined by JVM spec.
- `float` requires `f` suffix.
- `long` requires `L` suffix if value exceeds int range.

---

## 2's Complement in Java
Twoâ€™s complement is a method to represent negative numbers in binary.

### Steps to Find 2â€™s Complement
1. Convert number to binary
2. Invert all bits (1â€™s complement)
3. Add 1

### Example: Represent -5 (8-bit)

5 = 00000101

1â€™s complement:
11111010

Add 1:
11111011

So, -5 = 11111011

### Key Points
- MSB (Most Significant Bit) represents sign (0 = positive, 1 = negative)
- int range = -2^31 to 2^31 - 1
- Only one representation of zero


--- 

## Types of Type Conversion in Java

### 1. Widening (Implicit Conversion)
Smaller â†’ Larger data type.
Done automatically. No data loss.

Example:
int a = 10;
double b = a;   // int â†’ double (automatic)
System.out.println(b);  // 10.0

Flow:
byte â†’ short â†’ int â†’ long â†’ float â†’ double

---

### 2. Narrowing (Explicit Conversion)
Larger â†’ Smaller data type.
Manual casting required. May cause data loss.

Syntax:
(target_type) value

Example:
double x = 10.75;
int y = (int) x;
System.out.println(y);  // 10 => Decimal part is lost.

---

### 3. Type Promotion in Expressions
Java automatically promotes smaller types:
```byte, short, char â†’ int```

Example:
```java
byte a = 10;
byte b = 20;
int c = a + b;  // result is int
```

### ğŸ§  Important Rules
âœ” boolean cannot be converted to any other type
âœ” Cannot convert object types like primitives
âœ” Arithmetic operations auto-promote to int

---

## Kinds of Variables in Java

### 1ï¸âƒ£ Instance (Member) Variables
- Declared inside a class but outside methods
- Each object gets its own copy
```java
class Student {
    String name;   // instance variable
    int age;       // instance variable
}
```

```java
Student s1 = new Student();
Student s2 = new Student();
```
Memory:
- s1.name â†’ separate
- s2.name â†’ separate

ğŸ§  Key Points
âœ” Stored in Heap memory
âœ” Created when object is created
âœ” Destroyed when object is destroyed
âœ” Gets default values
âœ” Accessed using object reference


### 2ï¸âƒ£ Static Variables (Class Variables)
- Declared using static keyword
- Only ONE copy shared among all objects
```java
class Student {
    static String schoolName = "ABC School";
}
```
```java
Student.schoolName = "XYZ School";
```
Memory:
- Only one copy
- Shared by all objects

ğŸ§  Key Points
âœ” Stored in **Method Area (Metaspace in modern JVM)**
âœ” Created when class is loaded
âœ” Shared among all objects
âœ” Gets default values
âœ” Access using: ClassName.variable



### 3ï¸âƒ£ Local Variables (Very Important)
- Declared inside a method, constructor, or block
```java
class Test {
    void display() {
        int x = 10;   // local variable
    }
}
```

ğŸ§  Key Points
âœ” Stored in Stack memory
âœ” Created when method is called
âœ” Destroyed when method ends
âœ” âŒ No default value (must initialize)
âœ” Cannot use access modifiers

---

## Pass by Value vs Pass by Reference in Java
ğŸš¨ Important Truth
- Java is 100% Pass by Value.
- There is NO pass by reference in Java.

ğŸ§  What Does â€œPass by Valueâ€ Mean?
- When a method is called:
- A copy of the variable is passed
- Changes inside method do NOT affect original variable (for primitives)

1ï¸âƒ£ Primitive Types (Clear Example)
```java
class Test {
    static void change(int x) {
        x = 100;
    }

    public static void main(String[] args) {
        int a = 10;
        change(a);
        System.out.println(a);   // prints 10
    }
}
```
Why?
- a is copied into x
- Changing x doesnâ€™t change a


2ï¸âƒ£ Objects (Where Confusion Happens)
```java
class Student {
    String name;
}

class Test {
    static void change(Student s) {
        s.name = "Rahul";
    }

    public static void main(String[] args) {
        Student st = new Student();
        st.name = "Abhi";

        change(st);
        System.out.println(st.name);    // Prints Rahul
    }
}
```

**Why Did It Change?**
Because:
- st stores a reference
- That reference is copied
- Both references point to the same object
- Modifying object affects original
ğŸ‘‰ But reference itself is still passed by value.

---

## Reference Data Types (Non-Primitive Date Types)
There are mainly 4 type of renference data types :
- Class
- String
- Interface
- Array

---

### What is renference ?
Let's understand with an example of class
So Let's create a class -
```java
public class Employee {
    private int id;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }
}
```

Now to create an object of class Employee
```java
public class Main {
    public static void main(String[] args) {
        Employee employee = new Employee();
    }
}
```
New keyword allocates a memory block object and the variable's name holds a reference to actual memory.
![alt text](image-1.png)

---

### String Reference Data Type in Java
ğŸ§  What is String?
```java
String s = "Hello";
```
Here:
String â†’ Class (from java.lang)
s â†’ Reference variable
"Hello" â†’ Object


ğŸ”¥ Where Strings Are Stored?
1ï¸âƒ£ String Literal (Stored in String Pool)
```java
String s1 = "Java";
String s2 = "Java";
```
âœ” Only ONE object created in String pool.
âœ” Both references point to same object


2ï¸âƒ£ Using new Keyword (Stored in Heap)
```java
String s3 = new String("Java");
```
âœ” Creates a NEW object
âœ” Does not reuse pool object


ğŸ§ª Comparison Example
```java
String s1 = "Java";
String s2 = "Java";
String s3 = new String("Java");

System.out.println(s1 == s2);      // true
System.out.println(s1 == s3);      // false
System.out.println(s1.equals(s3); // true
```


ğŸ§  Important: String is Immutable
```java
String s = "Java";
s.concat(" Backend");
System.out.println(s);      // Java
s = s.concat(" Backend");
System.out.println(s);      // Java Backend
```

Why?
- Strings cannot be modified
- concat() creates new object
- Original remains unchanged

ğŸ§  equals() vs ==
```java
String a = "Java";
String b = new String("Java");

a == b        // false
a.equals(b)   // true
```

- == â†’ reference comparison
- equals() â†’ content comparison


ğŸ§© Internal Structure (Simplified)
```java
public final class String {
    private final byte[] value;
}
```

âœ” final class
âœ” internal array is final
âœ” immutable design


---

## Interface Reference Data Type in Java
An interface can be used as a reference type to refer to an object of a class that implements it.

ğŸ§  Basic Idea
```java
interface Animal {
    void sound();
}

class Dog implements Animal {
    public void sound() {
        System.out.println("Dog barks");
    }
}
```

Now
```java
Animal a = new Dog();
a.sound();  // Dog barks
```

Here:
- Animal â†’ Interface (reference type)
- a â†’ Interface reference variable
- new Dog() â†’ Object
- Dog implements Animal


ğŸ“Œ Important Rules
1ï¸âƒ£ Interface cannot be instantiated
2ï¸âƒ£ Interface reference can only access Methods declared in interface
```java
Animal a = new Dog();
a.sound();  // OK

a.run();    // âŒ if run() not in Animal
```

ğŸ§  Very Important Concept
**Reference type determines what methods are accessible.**
**Object type determines which method implementation runs.**


---

## Array as Reference Data Type in Java
- Array is a reference data type.
- Array is an object stored in heap memory.
- Reference variable is stored in stack.
- Arrays are mutable.
- Arrays have fixed size.

```java
int[] arr = new int[3];
```

--- 

## Class as Reference Data Type in Java

- A class is a blueprint for creating objects.
- Objects are stored in heap memory.
- Reference variable stores address of object.
- Multiple references can point to same object.

Example:
```java
Student s1 = new Student();
```

Memory:
s1 â†’ Student object in heap


--- 

## Wrapper Classes
- Wrapper classes are object representations of primitive data types.
- Primitive â†’ Wrapper Mapping
| Primitive | Wrapper Class |
| --------- | ------------- |
| byte      | Byte          |
| short     | Short         |
| int       | Integer       |
| long      | Long          |
| float     | Float         |
| double    | Double        |
| char      | Character     |
| boolean   | Boolean       |

- All wrapper classes are in: ```java.lang package```
- **Wrapper Objects Are Immutable**


ğŸ“Œ Why Do We Need Wrapper Classes?
Primitives are:
- Not objects
- Cannot be used in Collections
- Cannot call methods
- Cannot be null
But many Java features require objects.


ğŸ“Œ What is Boxing?
ğŸ”¹ Manual Boxing (Before Java 5)
Converting primitive â†’ wrapper manually:
```java
int a = 10;
Integer obj = new Integer(a);  // old way (deprecated)
```
Better way:
```java
Integer obj = Integer.valueOf(a);
```


ğŸ“Œ What is Autoboxing?
Automatic conversion of primitive â†’ wrapper
```java
int a = 10;
Integer obj = a;   // Autoboxing
```

Compiler converts it to:
```java
Integer obj = Integer.valueOf(a);
```

ğŸ“Œ What is Unboxing?
Automatic conversion of wrapper â†’ primitive
```java
Integer obj = 20;
int a = obj;   // Unboxing
```
Compiler converts it to:
```java
int a = obj.intValue();
```

ğŸ§  Real Example (Collections)
```java
ArrayList<Integer> list = new ArrayList<>();

list.add(10);  // autoboxing
int x = list.get(0);  // unboxing
```


### Integer Caching (Very Important Interview Question)
```java
Integer a = 100;
Integer b = 100;

System.out.println(a == b);  // true
```
Why?
Because Java caches values from: -128 to 127

But:
```java
Integer a = 200;
Integer b = 200;

System.out.println(a == b);  // false
```
Because outside cache range.

---

## Constant Variable
- We cannot change the value of a constant variable. This is usually created using final keyword.
```java
Static final VAR = 10;
```
static => It means only one copy exists
final => It means value of var can't be changed.