# JVM_JRE_JDK
---

## What is Java?
- Platform independent language
- Supports OOPS
- Portable (WORA - Write Once Run Anywhere)

### 3 main components :
![alt text](images/1_QiqeemtqKaSUIJzKCB9C0Q.webp)

#### JVM (Java Virtual Machine)
It's just an abstract machine that doesn't exist physically.

![alt text](images/bytecode-machinecode.png)

- So JVM is platform dependent
- So we need to install JVM based on the platform i. e MacOS, Linux or windows. Input for JVM is bytecode & output is machine co.de Now since bydecode can run by any JVM, it makes a Java program platform independent.
- JVM has JIT (Just In Time) compiler which takes byrecode & convert it into machine code.

---

#### JRE : Java Runtime Environment
- JRE Contains JVM & class libraries i.e. the libraries which we've used in the code.
- So if we have JRE, we can run any Java Program but we cannot code the program.

---

#### JDK : Java Development Kit
- It has programs language information
- It has compiler (javac)
- It has debugger

So JDK = JRE + (Program Language + compiler + debugger + other dev components)

**Note: So JVM, JRE and JDK all three are platform dependent but the Compiled bytecode is platform independent.**

---

#### JIT : Just-In-Time compiler
JIT (Just-In-Time) Compiler is a part of the JVM that converts bytecode into native machine code at runtime to improve performance.

**‚öôÔ∏è How JIT Works (Step-by-step)**
1Ô∏è‚É£ You compile Java code
```bash
javac MyClass.java
```
‚Üí Generates bytecode

2Ô∏è‚É£ JVM starts running the program
‚Üí Uses Interpreter initially

3Ô∏è‚É£ JVM monitors which methods run frequently
‚Üí These are called Hot Spots

4Ô∏è‚É£ JIT compiles hot methods into native machine code

5Ô∏è‚É£ Next time method runs
‚Üí Directly executes native code
‚Üí ‚ö° Much faster

üß™ Example
```java
for(int i = 0; i < 1_000_000; i++) {
    sum += calculate();
}
```
If calculate() is called many times:
- JVM marks it as ‚Äúhot‚Äù
- JIT compiles it to machine code
- Future calls are super fast
